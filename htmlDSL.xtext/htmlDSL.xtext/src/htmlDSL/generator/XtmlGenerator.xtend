/*
 * generated by Xtext 2.27.0
 */
package htmlDSL.generator

import htmlDSL.generator.objects.ContainerObj
import htmlDSL.generator.objects.DefinitionObj
import htmlDSL.generator.objects.TextObj
import htmlDSL.xtml.ContainerDefinition
import htmlDSL.xtml.Definition
import htmlDSL.xtml.Expression
import htmlDSL.xtml.FunctionCall
import htmlDSL.xtml.TextDefinition
import java.util.HashMap
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import htmlDSL.xtml.ImageDefinition
import htmlDSL.generator.objects.ImageObj

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class XtmlGenerator extends AbstractGenerator {

	// Arraylist for getting the order of the expressions correct
	// ArrayList<ExpressionObj> expressionArr = new ArrayList()
	// hashmap for quick access to objects by name. They are unordered in Java
	HashMap<String, DefinitionObj> definitionMap = newHashMap

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		var output = ""
		// output += "resource.URI.file : " + resource.URI.isFile + "\n"
		// output += "resource.URI.fileExtension : " + resource.URI.fileExtension + "\n"
		// output += "resource.URI.fileExtension != 'xtml' : " + (resource.URI.fileExtension != "xtml") + "\n"
		if(resource.URI.fileExtension != "xtml") return

		var path = resource.URI.path.split("/")
		var fileName = path.get(path.length - 1)
		fileName = fileName.substring(0, fileName.lastIndexOf('.'))
		// output += "filename : " + fileName + "\n"
		// fsa.deleteFile(fileName + ".html")
		// PASS 1 --> MAPPING EXPRESSIONS TO APPROPRIATE OBJECTS
		init(resource.allContents.filter(Expression).toIterable())

		var css = "<style>\n"
		var body = ""
		// PASS 2 --> USING OBJECTS TO CONSTRUCT HTML TAGS
		for (DefinitionObj exo : definitionMap.values) {
			var exo_css = exo.createCSS
			if (exo_css != "") css +=  exo_css + '\n'
			if (!exo.contained) {
				body += exo.createTag
			}
		}
		css += "</style>\n"

		output += "<html>\n<head\n>"

		// head stuff here, like script and style
		output += css
		output += "</head>\n<body>\n"

		// body stuff; all visible content
		output += body
		output += "</body>\n</html>"

		// generate the file with the content
		fsa.generateFile(fileName + ".html", output)
		definitionMap.clear
	}

	def void init(Iterable<Expression> expressions) {
		for (Expression exp : expressions) {
			switch (exp) {
				ContainerDefinition: initContainer(exp)
				TextDefinition: initText(exp)
				ImageDefinition: initImage(exp)
				FunctionCall: initFunctionCall(exp)
			}
		}
	}

	def void initContainer(ContainerDefinition c) {
		var conObj = new ContainerObj(c.name, c.type)

		definitionMap.put(conObj.name, conObj)

		// all the containing elements at creation
		for (Definition defin : c.objects) {
			var obj = definitionMap.get(defin.name)
			if (obj !== null) {
				obj.contained = true
				conObj.add(obj)
			}
		}
	}

	def void initText(TextDefinition t) {
		var textObj = new TextObj(t.name, t.type, t.text)

		definitionMap.put(textObj.name, textObj)
	}
	
	def void initImage (ImageDefinition i) {
		var imageObj = new ImageObj(i.name, i.type, i.src, i.alt)
		
		definitionMap.put(imageObj.name, imageObj)
	}
	
	def void initFunctionCall(FunctionCall fc) {
		// add parameter to appropriate object
		definitionMap.get(fc.ref.name).callFunction(fc.func, definitionMap)
	}
}
